/* tslint:disable */
/* eslint-disable */
/*
Appwrite

Appwrite backend as a service cuts up to 70% of the time and costs required for building a modern application. We abstract and simplify common development tasks behind a REST APIs, to help you develop your app in a fast and secure way. For full API documentation and tutorials go to [https://appwrite.io/docs](https://appwrite.io/docs)

The version of the OpenAPI document: 1.5.0
Contact: team@appwrite.io

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { HealthAntivirus } from '../models';
// @ts-ignore
import { HealthCertificate } from '../models';
// @ts-ignore
import { HealthQueue } from '../models';
// @ts-ignore
import { HealthStatus } from '../models';
// @ts-ignore
import { HealthTime } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check the Appwrite Antivirus server is up and connection is successful.
         * @summary Get antivirus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAntivirusStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/anti-virus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/anti-virus',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite in-memory cache servers are up and connection is successful.
         * @summary Get cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkCacheStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/cache`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/cache',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite database servers are up and connection is successful.
         * @summary Get DB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDbStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/db`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/db',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite local storage device is up and connection is successful.
         * @summary Get local storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkLocalStorageStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/storage/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/storage/local',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite pub-sub servers are up and connection is successful.
         * @summary Get pubsub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPubsubServerStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/pubsub`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/pubsub',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite HTTP server is up and responsive.
         * @summary Get HTTP
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkServerStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite storage device is up and connection is successful.
         * @summary Get storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkStorageStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/storage',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of function executions that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get functions queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsQueueCount: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/functions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/functions',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of builds that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get builds queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildsQueue: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/builds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/builds',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of database changes that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get databases queue
         * @param {string} [name] Queue name for which to check the queue size
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabasesQueue: async (name?: string, threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/databases',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of background destructive changes that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get deletes queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletesQueue: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/deletes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/deletes',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the amount of failed jobs in a given queue. 
         * @summary Get number of failed queue jobs
         * @param {'v1-database' | 'v1-deletes' | 'v1-audits' | 'v1-mails' | 'v1-functions' | 'v1-usage' | 'v1-usage-dump' | 'webhooksv1' | 'v1-certificates' | 'v1-builds' | 'v1-messaging' | 'v1-migrations' | 'hamsterv1'} name The name of the queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFailedJobs: async (name: 'v1-database' | 'v1-deletes' | 'v1-audits' | 'v1-mails' | 'v1-functions' | 'v1-usage' | 'v1-usage-dump' | 'webhooksv1' | 'v1-certificates' | 'v1-builds' | 'v1-messaging' | 'v1-migrations' | 'hamsterv1', threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getFailedJobs', 'name', name)
            const localVarPath = `/health/queue/failed/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name !== undefined ? name : `-name-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/failed/{name}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of mails that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get mails queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailQueueSize: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/mails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/mails',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of migrations that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get migrations queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMigrationsQueue: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/migrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/migrations',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of logs that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get logs queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueLogs: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/logs',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of messages that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get messaging queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueMessaging: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/messaging`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/messaging',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite queue messaging servers are up and connection is successful.
         * @summary Get queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of metrics that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get usage queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueUsage: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/usage',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of projects containing metrics that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get usage dump queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueUsageDump: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/usage-dump`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/usage-dump',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the SSL certificate for a domain
         * @summary Get the SSL certificate for a domain
         * @param {string} [domain] string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSslCert: async (domain?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/certificate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/certificate',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the Appwrite server time is synced with Google remote NTP server. We use this technology to smoothly handle leap seconds with no disruptive events. The [Network Time Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (NTP) is used by hundreds of millions of computers and devices to synchronize their clocks over the Internet. If your computer sets its own clock, it likely uses NTP.
         * @summary Get time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeInformation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/time',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of webhooks that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get webhooks queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksQueue: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/webhooks',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of certificates that are waiting to be issued against [Letsencrypt](https://letsencrypt.org/) in the Appwrite internal queue server.
         * @summary Get certificates queue
         * @param {number} [threshold] Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueCertificatesGet: async (threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/queue/certificates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/health/queue/certificates',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Check the Appwrite Antivirus server is up and connection is successful.
         * @summary Get antivirus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkAntivirusStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthAntivirus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkAntivirusStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite in-memory cache servers are up and connection is successful.
         * @summary Get cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkCacheStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkCacheStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite database servers are up and connection is successful.
         * @summary Get DB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDbStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDbStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite local storage device is up and connection is successful.
         * @summary Get local storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkLocalStorageStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkLocalStorageStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite pub-sub servers are up and connection is successful.
         * @summary Get pubsub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPubsubServerStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkPubsubServerStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite HTTP server is up and responsive.
         * @summary Get HTTP
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkServerStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkServerStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite storage device is up and connection is successful.
         * @summary Get storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkStorageStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkStorageStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of function executions that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get functions queue
         * @param {HealthApiFunctionsQueueCountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionsQueueCount(requestParameters: HealthApiFunctionsQueueCountRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionsQueueCount(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of builds that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get builds queue
         * @param {HealthApiGetBuildsQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuildsQueue(requestParameters: HealthApiGetBuildsQueueRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildsQueue(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of database changes that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get databases queue
         * @param {HealthApiGetDatabasesQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabasesQueue(requestParameters: HealthApiGetDatabasesQueueRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabasesQueue(requestParameters.name, requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of background destructive changes that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get deletes queue
         * @param {HealthApiGetDeletesQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeletesQueue(requestParameters: HealthApiGetDeletesQueueRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeletesQueue(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the amount of failed jobs in a given queue. 
         * @summary Get number of failed queue jobs
         * @param {HealthApiGetFailedJobsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFailedJobs(requestParameters: HealthApiGetFailedJobsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFailedJobs(requestParameters.name, requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of mails that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get mails queue
         * @param {HealthApiGetMailQueueSizeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMailQueueSize(requestParameters: HealthApiGetMailQueueSizeRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMailQueueSize(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of migrations that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get migrations queue
         * @param {HealthApiGetMigrationsQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMigrationsQueue(requestParameters: HealthApiGetMigrationsQueueRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMigrationsQueue(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of logs that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get logs queue
         * @param {HealthApiGetQueueLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueLogs(requestParameters: HealthApiGetQueueLogsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueLogs(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of messages that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get messaging queue
         * @param {HealthApiGetQueueMessagingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueMessaging(requestParameters: HealthApiGetQueueMessagingRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueMessaging(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite queue messaging servers are up and connection is successful.
         * @summary Get queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of metrics that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get usage queue
         * @param {HealthApiGetQueueUsageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueUsage(requestParameters: HealthApiGetQueueUsageRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueUsage(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of projects containing metrics that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get usage dump queue
         * @param {HealthApiGetQueueUsageDumpRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueUsageDump(requestParameters: HealthApiGetQueueUsageDumpRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueUsageDump(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the SSL certificate for a domain
         * @summary Get the SSL certificate for a domain
         * @param {HealthApiGetSslCertRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSslCert(requestParameters: HealthApiGetSslCertRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCertificate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSslCert(requestParameters.domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the Appwrite server time is synced with Google remote NTP server. We use this technology to smoothly handle leap seconds with no disruptive events. The [Network Time Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (NTP) is used by hundreds of millions of computers and devices to synchronize their clocks over the Internet. If your computer sets its own clock, it likely uses NTP.
         * @summary Get time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimeInformation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthTime>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeInformation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of webhooks that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get webhooks queue
         * @param {HealthApiGetWebhooksQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooksQueue(requestParameters: HealthApiGetWebhooksQueueRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooksQueue(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the number of certificates that are waiting to be issued against [Letsencrypt](https://letsencrypt.org/) in the Appwrite internal queue server.
         * @summary Get certificates queue
         * @param {HealthApiQueueCertificatesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueCertificatesGet(requestParameters: HealthApiQueueCertificatesGetRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queueCertificatesGet(requestParameters.threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Check the Appwrite Antivirus server is up and connection is successful.
         * @summary Get antivirus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAntivirusStatus(options?: AxiosRequestConfig): AxiosPromise<HealthAntivirus> {
            return localVarFp.checkAntivirusStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite in-memory cache servers are up and connection is successful.
         * @summary Get cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkCacheStatus(options?: AxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.checkCacheStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite database servers are up and connection is successful.
         * @summary Get DB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDbStatus(options?: AxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.checkDbStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite local storage device is up and connection is successful.
         * @summary Get local storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkLocalStorageStatus(options?: AxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.checkLocalStorageStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite pub-sub servers are up and connection is successful.
         * @summary Get pubsub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPubsubServerStatus(options?: AxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.checkPubsubServerStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite HTTP server is up and responsive.
         * @summary Get HTTP
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkServerStatus(options?: AxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.checkServerStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite storage device is up and connection is successful.
         * @summary Get storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkStorageStatus(options?: AxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.checkStorageStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of function executions that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get functions queue
         * @param {HealthApiFunctionsQueueCountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsQueueCount(requestParameters: HealthApiFunctionsQueueCountRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.functionsQueueCount(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of builds that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get builds queue
         * @param {HealthApiGetBuildsQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildsQueue(requestParameters: HealthApiGetBuildsQueueRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getBuildsQueue(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of database changes that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get databases queue
         * @param {HealthApiGetDatabasesQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabasesQueue(requestParameters: HealthApiGetDatabasesQueueRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getDatabasesQueue(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of background destructive changes that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get deletes queue
         * @param {HealthApiGetDeletesQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletesQueue(requestParameters: HealthApiGetDeletesQueueRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getDeletesQueue(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the amount of failed jobs in a given queue. 
         * @summary Get number of failed queue jobs
         * @param {HealthApiGetFailedJobsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFailedJobs(requestParameters: HealthApiGetFailedJobsRequest, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getFailedJobs(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of mails that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get mails queue
         * @param {HealthApiGetMailQueueSizeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailQueueSize(requestParameters: HealthApiGetMailQueueSizeRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getMailQueueSize(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of migrations that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get migrations queue
         * @param {HealthApiGetMigrationsQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMigrationsQueue(requestParameters: HealthApiGetMigrationsQueueRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getMigrationsQueue(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of logs that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get logs queue
         * @param {HealthApiGetQueueLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueLogs(requestParameters: HealthApiGetQueueLogsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getQueueLogs(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of messages that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get messaging queue
         * @param {HealthApiGetQueueMessagingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueMessaging(requestParameters: HealthApiGetQueueMessagingRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getQueueMessaging(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite queue messaging servers are up and connection is successful.
         * @summary Get queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueStatus(options?: AxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.getQueueStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of metrics that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get usage queue
         * @param {HealthApiGetQueueUsageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueUsage(requestParameters: HealthApiGetQueueUsageRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getQueueUsage(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of projects containing metrics that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get usage dump queue
         * @param {HealthApiGetQueueUsageDumpRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueUsageDump(requestParameters: HealthApiGetQueueUsageDumpRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getQueueUsageDump(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the SSL certificate for a domain
         * @summary Get the SSL certificate for a domain
         * @param {HealthApiGetSslCertRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSslCert(requestParameters: HealthApiGetSslCertRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthCertificate> {
            return localVarFp.getSslCert(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Check the Appwrite server time is synced with Google remote NTP server. We use this technology to smoothly handle leap seconds with no disruptive events. The [Network Time Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (NTP) is used by hundreds of millions of computers and devices to synchronize their clocks over the Internet. If your computer sets its own clock, it likely uses NTP.
         * @summary Get time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeInformation(options?: AxiosRequestConfig): AxiosPromise<HealthTime> {
            return localVarFp.getTimeInformation(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of webhooks that are waiting to be processed in the Appwrite internal queue server.
         * @summary Get webhooks queue
         * @param {HealthApiGetWebhooksQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksQueue(requestParameters: HealthApiGetWebhooksQueueRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.getWebhooksQueue(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of certificates that are waiting to be issued against [Letsencrypt](https://letsencrypt.org/) in the Appwrite internal queue server.
         * @summary Get certificates queue
         * @param {HealthApiQueueCertificatesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueCertificatesGet(requestParameters: HealthApiQueueCertificatesGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<HealthQueue> {
            return localVarFp.queueCertificatesGet(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for functionsQueueCount operation in HealthApi.
 * @export
 * @interface HealthApiFunctionsQueueCountRequest
 */
export type HealthApiFunctionsQueueCountRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiFunctionsQueueCount
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getBuildsQueue operation in HealthApi.
 * @export
 * @interface HealthApiGetBuildsQueueRequest
 */
export type HealthApiGetBuildsQueueRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetBuildsQueue
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getDatabasesQueue operation in HealthApi.
 * @export
 * @interface HealthApiGetDatabasesQueueRequest
 */
export type HealthApiGetDatabasesQueueRequest = {
    
    /**
    * Queue name for which to check the queue size
    * @type {string}
    * @memberof HealthApiGetDatabasesQueue
    */
    readonly name?: string
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetDatabasesQueue
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getDeletesQueue operation in HealthApi.
 * @export
 * @interface HealthApiGetDeletesQueueRequest
 */
export type HealthApiGetDeletesQueueRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetDeletesQueue
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getFailedJobs operation in HealthApi.
 * @export
 * @interface HealthApiGetFailedJobsRequest
 */
export type HealthApiGetFailedJobsRequest = {
    
    /**
    * The name of the queue
    * @type {'v1-database' | 'v1-deletes' | 'v1-audits' | 'v1-mails' | 'v1-functions' | 'v1-usage' | 'v1-usage-dump' | 'webhooksv1' | 'v1-certificates' | 'v1-builds' | 'v1-messaging' | 'v1-migrations' | 'hamsterv1'}
    * @memberof HealthApiGetFailedJobs
    */
    readonly name: 'v1-database' | 'v1-deletes' | 'v1-audits' | 'v1-mails' | 'v1-functions' | 'v1-usage' | 'v1-usage-dump' | 'webhooksv1' | 'v1-certificates' | 'v1-builds' | 'v1-messaging' | 'v1-migrations' | 'hamsterv1'
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetFailedJobs
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getMailQueueSize operation in HealthApi.
 * @export
 * @interface HealthApiGetMailQueueSizeRequest
 */
export type HealthApiGetMailQueueSizeRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetMailQueueSize
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getMigrationsQueue operation in HealthApi.
 * @export
 * @interface HealthApiGetMigrationsQueueRequest
 */
export type HealthApiGetMigrationsQueueRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetMigrationsQueue
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getQueueLogs operation in HealthApi.
 * @export
 * @interface HealthApiGetQueueLogsRequest
 */
export type HealthApiGetQueueLogsRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetQueueLogs
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getQueueMessaging operation in HealthApi.
 * @export
 * @interface HealthApiGetQueueMessagingRequest
 */
export type HealthApiGetQueueMessagingRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetQueueMessaging
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getQueueUsage operation in HealthApi.
 * @export
 * @interface HealthApiGetQueueUsageRequest
 */
export type HealthApiGetQueueUsageRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetQueueUsage
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getQueueUsageDump operation in HealthApi.
 * @export
 * @interface HealthApiGetQueueUsageDumpRequest
 */
export type HealthApiGetQueueUsageDumpRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetQueueUsageDump
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for getSslCert operation in HealthApi.
 * @export
 * @interface HealthApiGetSslCertRequest
 */
export type HealthApiGetSslCertRequest = {
    
    /**
    * string
    * @type {string}
    * @memberof HealthApiGetSslCert
    */
    readonly domain?: string
    
}

/**
 * Request parameters for getWebhooksQueue operation in HealthApi.
 * @export
 * @interface HealthApiGetWebhooksQueueRequest
 */
export type HealthApiGetWebhooksQueueRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiGetWebhooksQueue
    */
    readonly threshold?: number
    
}

/**
 * Request parameters for queueCertificatesGet operation in HealthApi.
 * @export
 * @interface HealthApiQueueCertificatesGetRequest
 */
export type HealthApiQueueCertificatesGetRequest = {
    
    /**
    * Queue size threshold. When hit (equal or higher), endpoint returns server error. Default value is 5000.
    * @type {number}
    * @memberof HealthApiQueueCertificatesGet
    */
    readonly threshold?: number
    
}

/**
 * HealthApiGenerated - object-oriented interface
 * @export
 * @class HealthApiGenerated
 * @extends {BaseAPI}
 */
export class HealthApiGenerated extends BaseAPI {
    /**
     * Check the Appwrite Antivirus server is up and connection is successful.
     * @summary Get antivirus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public checkAntivirusStatus(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkAntivirusStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite in-memory cache servers are up and connection is successful.
     * @summary Get cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public checkCacheStatus(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkCacheStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite database servers are up and connection is successful.
     * @summary Get DB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public checkDbStatus(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkDbStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite local storage device is up and connection is successful.
     * @summary Get local storage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public checkLocalStorageStatus(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkLocalStorageStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite pub-sub servers are up and connection is successful.
     * @summary Get pubsub
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public checkPubsubServerStatus(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkPubsubServerStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite HTTP server is up and responsive.
     * @summary Get HTTP
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public checkServerStatus(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkServerStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite storage device is up and connection is successful.
     * @summary Get storage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public checkStorageStatus(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkStorageStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of function executions that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get functions queue
     * @param {HealthApiFunctionsQueueCountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public functionsQueueCount(requestParameters: HealthApiFunctionsQueueCountRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).functionsQueueCount(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of builds that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get builds queue
     * @param {HealthApiGetBuildsQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getBuildsQueue(requestParameters: HealthApiGetBuildsQueueRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getBuildsQueue(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of database changes that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get databases queue
     * @param {HealthApiGetDatabasesQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getDatabasesQueue(requestParameters: HealthApiGetDatabasesQueueRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getDatabasesQueue(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of background destructive changes that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get deletes queue
     * @param {HealthApiGetDeletesQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getDeletesQueue(requestParameters: HealthApiGetDeletesQueueRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getDeletesQueue(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the amount of failed jobs in a given queue. 
     * @summary Get number of failed queue jobs
     * @param {HealthApiGetFailedJobsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getFailedJobs(requestParameters: HealthApiGetFailedJobsRequest, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getFailedJobs(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of mails that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get mails queue
     * @param {HealthApiGetMailQueueSizeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getMailQueueSize(requestParameters: HealthApiGetMailQueueSizeRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getMailQueueSize(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of migrations that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get migrations queue
     * @param {HealthApiGetMigrationsQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getMigrationsQueue(requestParameters: HealthApiGetMigrationsQueueRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getMigrationsQueue(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of logs that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get logs queue
     * @param {HealthApiGetQueueLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getQueueLogs(requestParameters: HealthApiGetQueueLogsRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getQueueLogs(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of messages that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get messaging queue
     * @param {HealthApiGetQueueMessagingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getQueueMessaging(requestParameters: HealthApiGetQueueMessagingRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getQueueMessaging(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite queue messaging servers are up and connection is successful.
     * @summary Get queue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getQueueStatus(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getQueueStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of metrics that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get usage queue
     * @param {HealthApiGetQueueUsageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getQueueUsage(requestParameters: HealthApiGetQueueUsageRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getQueueUsage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of projects containing metrics that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get usage dump queue
     * @param {HealthApiGetQueueUsageDumpRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getQueueUsageDump(requestParameters: HealthApiGetQueueUsageDumpRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getQueueUsageDump(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the SSL certificate for a domain
     * @summary Get the SSL certificate for a domain
     * @param {HealthApiGetSslCertRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getSslCert(requestParameters: HealthApiGetSslCertRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getSslCert(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the Appwrite server time is synced with Google remote NTP server. We use this technology to smoothly handle leap seconds with no disruptive events. The [Network Time Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (NTP) is used by hundreds of millions of computers and devices to synchronize their clocks over the Internet. If your computer sets its own clock, it likely uses NTP.
     * @summary Get time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getTimeInformation(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getTimeInformation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of webhooks that are waiting to be processed in the Appwrite internal queue server.
     * @summary Get webhooks queue
     * @param {HealthApiGetWebhooksQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public getWebhooksQueue(requestParameters: HealthApiGetWebhooksQueueRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getWebhooksQueue(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of certificates that are waiting to be issued against [Letsencrypt](https://letsencrypt.org/) in the Appwrite internal queue server.
     * @summary Get certificates queue
     * @param {HealthApiQueueCertificatesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiGenerated
     */
    public queueCertificatesGet(requestParameters: HealthApiQueueCertificatesGetRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).queueCertificatesGet(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
