/* tslint:disable */
/* eslint-disable */
/*
Appwrite

Appwrite backend as a service cuts up to 70% of the time and costs required for building a modern application. We abstract and simplify common development tasks behind a REST APIs, to help you develop your app in a fast and secure way. For full API documentation and tutorials go to [https://appwrite.io/docs](https://appwrite.io/docs)

The version of the OpenAPI document: 1.5.0
Contact: team@appwrite.io

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { IdentityList } from '../models';
// @ts-ignore
import { LogList } from '../models';
// @ts-ignore
import { MembershipList } from '../models';
// @ts-ignore
import { MfaFactors } from '../models';
// @ts-ignore
import { MfaRecoveryCodes } from '../models';
// @ts-ignore
import { Session } from '../models';
// @ts-ignore
import { SessionList } from '../models';
// @ts-ignore
import { Target } from '../models';
// @ts-ignore
import { TargetList } from '../models';
// @ts-ignore
import { Token } from '../models';
// @ts-ignore
import { User } from '../models';
// @ts-ignore
import { UserList } from '../models';
// @ts-ignore
import { UsersCreateArgon2UserRequest } from '../models';
// @ts-ignore
import { UsersCreateBcryptUserRequest } from '../models';
// @ts-ignore
import { UsersCreateMd5UserRequest } from '../models';
// @ts-ignore
import { UsersCreateNewUserRequest } from '../models';
// @ts-ignore
import { UsersCreatePhpassUserRequest } from '../models';
// @ts-ignore
import { UsersCreateScryptModifiedUserRequest } from '../models';
// @ts-ignore
import { UsersCreateScryptUserRequest } from '../models';
// @ts-ignore
import { UsersCreateShaUserRequest } from '../models';
// @ts-ignore
import { UsersCreateTargetMessagingRequest } from '../models';
// @ts-ignore
import { UsersCreateTokenSessionRequest } from '../models';
// @ts-ignore
import { UsersUpdateEmailByIdRequest } from '../models';
// @ts-ignore
import { UsersUpdateEmailVerificationRequest } from '../models';
// @ts-ignore
import { UsersUpdateLabelsByIdRequest } from '../models';
// @ts-ignore
import { UsersUpdateMfaStatusRequest } from '../models';
// @ts-ignore
import { UsersUpdatePasswordByIdRequest } from '../models';
// @ts-ignore
import { UsersUpdatePhoneByIdRequest } from '../models';
// @ts-ignore
import { UsersUpdatePhoneVerificationRequest } from '../models';
// @ts-ignore
import { UsersUpdatePreferencesByIdRequest } from '../models';
// @ts-ignore
import { UsersUpdateStatusRequest } from '../models';
// @ts-ignore
import { UsersUpdateTargetMessagingRequest } from '../models';
// @ts-ignore
import { UsersUpdateUserByNameRequest } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user. Password provided must be hashed with the [Argon2](https://en.wikipedia.org/wiki/Argon2) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Argon2 password
         * @param {UsersCreateArgon2UserRequest} [usersCreateArgon2UserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArgon2User: async (usersCreateArgon2UserRequest?: UsersCreateArgon2UserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/argon2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateArgon2UserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/argon2',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateArgon2UserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user. Password provided must be hashed with the [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with bcrypt password
         * @param {UsersCreateBcryptUserRequest} [usersCreateBcryptUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBcryptUser: async (usersCreateBcryptUserRequest?: UsersCreateBcryptUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/bcrypt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateBcryptUserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/bcrypt',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateBcryptUserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user. Password provided must be hashed with the [MD5](https://en.wikipedia.org/wiki/MD5) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with MD5 password
         * @param {UsersCreateMd5UserRequest} [usersCreateMd5UserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMd5User: async (usersCreateMd5UserRequest?: UsersCreateMd5UserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/md5`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateMd5UserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/md5',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateMd5UserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate recovery codes used as backup for MFA flow for User ID. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method by client SDK.
         * @summary Create MFA Recovery Codes
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMfaRecoveryCodes: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createMfaRecoveryCodes', 'userId', userId)
            const localVarPath = `/users/{userId}/mfa/recovery-codes`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/mfa/recovery-codes',
                httpMethod: 'PATCH'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user.
         * @summary Create user
         * @param {UsersCreateNewUserRequest} [usersCreateNewUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewUser: async (usersCreateNewUserRequest?: UsersCreateNewUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateNewUserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateNewUserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user. Password provided must be hashed with the [PHPass](https://www.openwall.com/phpass/) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with PHPass password
         * @param {UsersCreatePhpassUserRequest} [usersCreatePhpassUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhpassUser: async (usersCreatePhpassUserRequest?: UsersCreatePhpassUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/phpass`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreatePhpassUserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/phpass',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreatePhpassUserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user. Password provided must be hashed with the [Scrypt Modified](https://gist.github.com/Meldiron/eecf84a0225eccb5a378d45bb27462cc) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Scrypt modified password
         * @param {UsersCreateScryptModifiedUserRequest} [usersCreateScryptModifiedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScryptModifiedUser: async (usersCreateScryptModifiedUserRequest?: UsersCreateScryptModifiedUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/scrypt-modified`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateScryptModifiedUserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/scrypt-modified',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateScryptModifiedUserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user. Password provided must be hashed with the [Scrypt](https://github.com/Tarsnap/scrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Scrypt password
         * @param {UsersCreateScryptUserRequest} [usersCreateScryptUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScryptUser: async (usersCreateScryptUserRequest?: UsersCreateScryptUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/scrypt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateScryptUserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/scrypt',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateScryptUserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a session for a user. Returns an immediately usable session object.  If you want to generate a token for a custom authentication flow, use the [POST /users/{userId}/tokens](https://appwrite.io/docs/server/users#createToken) endpoint.
         * @summary Create session
         * @param {string} userId User ID. Choose a custom ID or generate a random ID with &#x60;ID.unique()&#x60;. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can\&#39;t start with a special char. Max length is 36 chars.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createSession', 'userId', userId)
            const localVarPath = `/users/{userId}/sessions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/sessions',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user. Password provided must be hashed with the [SHA](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with SHA password
         * @param {UsersCreateShaUserRequest} [usersCreateShaUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShaUser: async (usersCreateShaUserRequest?: UsersCreateShaUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/sha`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateShaUserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/sha',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateShaUserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a messaging target.
         * @summary Create User Target
         * @param {string} userId User ID.
         * @param {UsersCreateTargetMessagingRequest} [usersCreateTargetMessagingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTargetMessaging: async (userId: string, usersCreateTargetMessagingRequest?: UsersCreateTargetMessagingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createTargetMessaging', 'userId', userId)
            const localVarPath = `/users/{userId}/targets`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateTargetMessagingRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/targets',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateTargetMessagingRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a token with a secret key for creating a session. If the provided user ID has not be registered, a new user will be created. Use the returned user ID and secret and submit a request to the [PUT /account/sessions/custom](https://appwrite.io/docs/references/cloud/client-web/account#updateCustomSession) endpoint to complete the login process.
         * @summary Create token
         * @param {string} userId User ID.
         * @param {UsersCreateTokenSessionRequest} [usersCreateTokenSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTokenSession: async (userId: string, usersCreateTokenSessionRequest?: UsersCreateTokenSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createTokenSession', 'userId', userId)
            const localVarPath = `/users/{userId}/tokens`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersCreateTokenSessionRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/tokens',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateTokenSessionRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an authenticator app.
         * @summary Delete Authenticator
         * @param {string} userId User ID.
         * @param {'totp'} type Type of authenticator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthenticator: async (userId: string, type: 'totp', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteAuthenticator', 'userId', userId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteAuthenticator', 'type', type)
            const localVarPath = `/users/{userId}/mfa/authenticators/{type}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type !== undefined ? type : `-type-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/mfa/authenticators/{type}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an identity by its unique ID.
         * @summary Delete identity
         * @param {string} identityId Identity ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityById: async (identityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('deleteIdentityById', 'identityId', identityId)
            const localVarPath = `/users/identities/{identityId}`
                .replace(`{${"identityId"}}`, encodeURIComponent(String(identityId !== undefined ? identityId : `-identityId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/identities/{identityId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user sessions by its unique ID.
         * @summary Delete user session
         * @param {string} userId User ID.
         * @param {string} sessionId Session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionById: async (userId: string, sessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteSessionById', 'userId', userId)
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deleteSessionById', 'sessionId', sessionId)
            const localVarPath = `/users/{userId}/sessions/{sessionId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)))
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId !== undefined ? sessionId : `-sessionId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/sessions/{sessionId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a messaging target.
         * @summary Delete user target
         * @param {string} userId User ID.
         * @param {string} targetId Target ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTargetMessaging: async (userId: string, targetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteTargetMessaging', 'userId', userId)
            // verify required parameter 'targetId' is not null or undefined
            assertParamExists('deleteTargetMessaging', 'targetId', targetId)
            const localVarPath = `/users/{userId}/targets/{targetId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)))
                .replace(`{${"targetId"}}`, encodeURIComponent(String(targetId !== undefined ? targetId : `-targetId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/targets/{targetId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user by its unique ID, thereby releasing it\'s ID. Since ID is released and can be reused, all user-related resources like documents or storage files should be deleted before user deletion. If you want to keep ID reserved, use the [updateStatus](https://appwrite.io/docs/server/users#usersUpdateStatus) endpoint instead.
         * @summary Delete user
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserById: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserById', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all user\'s sessions by using the user\'s unique ID.
         * @summary Delete user sessions
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserSessions: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserSessions', 'userId', userId)
            const localVarPath = `/users/{userId}/sessions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/sessions',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user by its unique ID.
         * @summary Get user
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getById', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recovery codes that can be used as backup for MFA flow by User ID. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
         * @summary Get MFA Recovery Codes
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMfaRecoveryCodes: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getMfaRecoveryCodes', 'userId', userId)
            const localVarPath = `/users/{userId}/mfa/recovery-codes`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/mfa/recovery-codes',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user preferences by its unique ID.
         * @summary Get user preferences
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPrefs: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserPrefs', 'userId', userId)
            const localVarPath = `/users/{userId}/prefs`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/prefs',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user\'s push notification target by ID.
         * @summary Get User Target
         * @param {string} userId User ID.
         * @param {string} targetId Target ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTargetById: async (userId: string, targetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserTargetById', 'userId', userId)
            // verify required parameter 'targetId' is not null or undefined
            assertParamExists('getUserTargetById', 'targetId', targetId)
            const localVarPath = `/users/{userId}/targets/{targetId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)))
                .replace(`{${"targetId"}}`, encodeURIComponent(String(targetId !== undefined ? targetId : `-targetId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/targets/{targetId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the project\'s users. You can use the query params to filter your results.
         * @summary List users
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, email, phone, status, passwordUpdate, registration, emailVerification, phoneVerification, labels
         * @param {string} [search] Search term to filter your list results. Max length: 256 chars.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAll: async (queries?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the factors available on the account to be used as a MFA challange.
         * @summary List Factors
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFactors: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listFactors', 'userId', userId)
            const localVarPath = `/users/{userId}/mfa/factors`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/mfa/factors',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get identities for all users.
         * @summary List Identities
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: userId, provider, providerUid, providerEmail, providerAccessTokenExpiry
         * @param {string} [search] Search term to filter your list results. Max length: 256 chars.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdentities: async (queries?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/identities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/identities',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user membership list by its unique ID.
         * @summary List user memberships
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMemberships: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listMemberships', 'userId', userId)
            const localVarPath = `/users/{userId}/memberships`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/memberships',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user sessions list by its unique ID.
         * @summary List user sessions
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSessions: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listSessions', 'userId', userId)
            const localVarPath = `/users/{userId}/sessions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/sessions',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the messaging targets that are associated with a user.
         * @summary List User Targets
         * @param {string} userId User ID.
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, email, phone, status, passwordUpdate, registration, emailVerification, phoneVerification, labels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTargets: async (userId: string, queries?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listTargets', 'userId', userId)
            const localVarPath = `/users/{userId}/targets`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/targets',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user activity logs list by its unique ID.
         * @summary List user logs
         * @param {string} userId User ID.
         * @param {Array<string>} [queries] Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserLogs: async (userId: string, queries?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserLogs', 'userId', userId)
            const localVarPath = `/users/{userId}/logs`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })
            if (queries) {
                localVarQueryParameter['queries'] = queries;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/logs',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Regenerate recovery codes that can be used as backup for MFA flow by User ID. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
         * @summary Regenerate MFA Recovery Codes
         * @param {string} userId User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateMfaRecoveryCodes: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('regenerateMfaRecoveryCodes', 'userId', userId)
            const localVarPath = `/users/{userId}/mfa/recovery-codes`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/mfa/recovery-codes',
                httpMethod: 'PUT'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user email by its unique ID.
         * @summary Update email
         * @param {string} userId User ID.
         * @param {UsersUpdateEmailByIdRequest} [usersUpdateEmailByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailById: async (userId: string, usersUpdateEmailByIdRequest?: UsersUpdateEmailByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateEmailById', 'userId', userId)
            const localVarPath = `/users/{userId}/email`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdateEmailByIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/email',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdateEmailByIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user email verification status by its unique ID.
         * @summary Update email verification
         * @param {string} userId User ID.
         * @param {UsersUpdateEmailVerificationRequest} [usersUpdateEmailVerificationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailVerification: async (userId: string, usersUpdateEmailVerificationRequest?: UsersUpdateEmailVerificationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateEmailVerification', 'userId', userId)
            const localVarPath = `/users/{userId}/verification`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdateEmailVerificationRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/verification',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdateEmailVerificationRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user labels by its unique ID.   Labels can be used to grant access to resources. While teams are a way for user\'s to share access to a resource, labels can be defined by the developer to grant access without an invitation. See the [Permissions docs](https://appwrite.io/docs/permissions) for more info.
         * @summary Update user labels
         * @param {string} userId User ID.
         * @param {UsersUpdateLabelsByIdRequest} [usersUpdateLabelsByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLabelsById: async (userId: string, usersUpdateLabelsByIdRequest?: UsersUpdateLabelsByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateLabelsById', 'userId', userId)
            const localVarPath = `/users/{userId}/labels`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdateLabelsByIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/labels',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdateLabelsByIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable or disable MFA on a user account.
         * @summary Update MFA
         * @param {string} userId User ID.
         * @param {UsersUpdateMfaStatusRequest} [usersUpdateMfaStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMfaStatus: async (userId: string, usersUpdateMfaStatusRequest?: UsersUpdateMfaStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateMfaStatus', 'userId', userId)
            const localVarPath = `/users/{userId}/mfa`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdateMfaStatusRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/mfa',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdateMfaStatusRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user password by its unique ID.
         * @summary Update password
         * @param {string} userId User ID.
         * @param {UsersUpdatePasswordByIdRequest} [usersUpdatePasswordByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordById: async (userId: string, usersUpdatePasswordByIdRequest?: UsersUpdatePasswordByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updatePasswordById', 'userId', userId)
            const localVarPath = `/users/{userId}/password`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdatePasswordByIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/password',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdatePasswordByIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user phone by its unique ID.
         * @summary Update phone
         * @param {string} userId User ID.
         * @param {UsersUpdatePhoneByIdRequest} [usersUpdatePhoneByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneById: async (userId: string, usersUpdatePhoneByIdRequest?: UsersUpdatePhoneByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updatePhoneById', 'userId', userId)
            const localVarPath = `/users/{userId}/phone`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdatePhoneByIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/phone',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdatePhoneByIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user phone verification status by its unique ID.
         * @summary Update phone verification
         * @param {string} userId User ID.
         * @param {UsersUpdatePhoneVerificationRequest} [usersUpdatePhoneVerificationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneVerification: async (userId: string, usersUpdatePhoneVerificationRequest?: UsersUpdatePhoneVerificationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updatePhoneVerification', 'userId', userId)
            const localVarPath = `/users/{userId}/verification/phone`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdatePhoneVerificationRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/verification/phone',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdatePhoneVerificationRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user preferences by its unique ID. The object you pass is stored as is, and replaces any previous value. The maximum allowed prefs size is 64kB and throws error if exceeded.
         * @summary Update user preferences
         * @param {string} userId User ID.
         * @param {UsersUpdatePreferencesByIdRequest} [usersUpdatePreferencesByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreferencesById: async (userId: string, usersUpdatePreferencesByIdRequest?: UsersUpdatePreferencesByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updatePreferencesById', 'userId', userId)
            const localVarPath = `/users/{userId}/prefs`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdatePreferencesByIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/prefs',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdatePreferencesByIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user status by its unique ID. Use this endpoint as an alternative to deleting a user if you want to keep user\'s ID reserved.
         * @summary Update user status
         * @param {string} userId User ID.
         * @param {UsersUpdateStatusRequest} [usersUpdateStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatus: async (userId: string, usersUpdateStatusRequest?: UsersUpdateStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateStatus', 'userId', userId)
            const localVarPath = `/users/{userId}/status`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdateStatusRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/status',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdateStatusRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a messaging target.
         * @summary Update User target
         * @param {string} userId User ID.
         * @param {string} targetId Target ID.
         * @param {UsersUpdateTargetMessagingRequest} [usersUpdateTargetMessagingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTargetMessaging: async (userId: string, targetId: string, usersUpdateTargetMessagingRequest?: UsersUpdateTargetMessagingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateTargetMessaging', 'userId', userId)
            // verify required parameter 'targetId' is not null or undefined
            assertParamExists('updateTargetMessaging', 'targetId', targetId)
            const localVarPath = `/users/{userId}/targets/{targetId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)))
                .replace(`{${"targetId"}}`, encodeURIComponent(String(targetId !== undefined ? targetId : `-targetId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdateTargetMessagingRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/targets/{targetId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdateTargetMessagingRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user name by its unique ID.
         * @summary Update name
         * @param {string} userId User ID.
         * @param {UsersUpdateUserByNameRequest} [usersUpdateUserByNameRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserByName: async (userId: string, usersUpdateUserByNameRequest?: UsersUpdateUserByNameRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserByName', 'userId', userId)
            const localVarPath = `/users/{userId}/name`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-userId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Key", keyParamName: "key", configuration })
            // authentication Project required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Appwrite-Project", keyParamName: "project", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersUpdateUserByNameRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{userId}/name',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdateUserByNameRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new user. Password provided must be hashed with the [Argon2](https://en.wikipedia.org/wiki/Argon2) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Argon2 password
         * @param {UsersApiCreateArgon2UserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArgon2User(requestParameters: UsersApiCreateArgon2UserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreateArgon2UserRequest: UsersCreateArgon2UserRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                password: requestParameters.password,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArgon2User(usersCreateArgon2UserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user. Password provided must be hashed with the [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with bcrypt password
         * @param {UsersApiCreateBcryptUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBcryptUser(requestParameters: UsersApiCreateBcryptUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreateBcryptUserRequest: UsersCreateBcryptUserRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                password: requestParameters.password,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBcryptUser(usersCreateBcryptUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user. Password provided must be hashed with the [MD5](https://en.wikipedia.org/wiki/MD5) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with MD5 password
         * @param {UsersApiCreateMd5UserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMd5User(requestParameters: UsersApiCreateMd5UserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreateMd5UserRequest: UsersCreateMd5UserRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                password: requestParameters.password,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMd5User(usersCreateMd5UserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate recovery codes used as backup for MFA flow for User ID. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method by client SDK.
         * @summary Create MFA Recovery Codes
         * @param {UsersApiCreateMfaRecoveryCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMfaRecoveryCodes(requestParameters: UsersApiCreateMfaRecoveryCodesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaRecoveryCodes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMfaRecoveryCodes(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user.
         * @summary Create user
         * @param {UsersApiCreateNewUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewUser(requestParameters: UsersApiCreateNewUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreateNewUserRequest: UsersCreateNewUserRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                phone: requestParameters.phone,
                password: requestParameters.password,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewUser(usersCreateNewUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user. Password provided must be hashed with the [PHPass](https://www.openwall.com/phpass/) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with PHPass password
         * @param {UsersApiCreatePhpassUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPhpassUser(requestParameters: UsersApiCreatePhpassUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreatePhpassUserRequest: UsersCreatePhpassUserRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                password: requestParameters.password,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPhpassUser(usersCreatePhpassUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user. Password provided must be hashed with the [Scrypt Modified](https://gist.github.com/Meldiron/eecf84a0225eccb5a378d45bb27462cc) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Scrypt modified password
         * @param {UsersApiCreateScryptModifiedUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScryptModifiedUser(requestParameters: UsersApiCreateScryptModifiedUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreateScryptModifiedUserRequest: UsersCreateScryptModifiedUserRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                password: requestParameters.password,
                passwordSalt: requestParameters.passwordSalt,
                passwordSaltSeparator: requestParameters.passwordSaltSeparator,
                passwordSignerKey: requestParameters.passwordSignerKey,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScryptModifiedUser(usersCreateScryptModifiedUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user. Password provided must be hashed with the [Scrypt](https://github.com/Tarsnap/scrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Scrypt password
         * @param {UsersApiCreateScryptUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScryptUser(requestParameters: UsersApiCreateScryptUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreateScryptUserRequest: UsersCreateScryptUserRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                password: requestParameters.password,
                passwordSalt: requestParameters.passwordSalt,
                passwordCpu: requestParameters.passwordCpu,
                passwordMemory: requestParameters.passwordMemory,
                passwordParallel: requestParameters.passwordParallel,
                passwordLength: requestParameters.passwordLength,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScryptUser(usersCreateScryptUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a session for a user. Returns an immediately usable session object.  If you want to generate a token for a custom authentication flow, use the [POST /users/{userId}/tokens](https://appwrite.io/docs/server/users#createToken) endpoint.
         * @summary Create session
         * @param {UsersApiCreateSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSession(requestParameters: UsersApiCreateSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user. Password provided must be hashed with the [SHA](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with SHA password
         * @param {UsersApiCreateShaUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShaUser(requestParameters: UsersApiCreateShaUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersCreateShaUserRequest: UsersCreateShaUserRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                password: requestParameters.password,
                passwordVersion: requestParameters.passwordVersion,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShaUser(usersCreateShaUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a messaging target.
         * @summary Create User Target
         * @param {UsersApiCreateTargetMessagingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTargetMessaging(requestParameters: UsersApiCreateTargetMessagingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Target>> {
            const usersCreateTargetMessagingRequest: UsersCreateTargetMessagingRequest = {
                targetId: requestParameters.targetId,
                providerType: requestParameters.providerType,
                identifier: requestParameters.identifier,
                providerId: requestParameters.providerId,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTargetMessaging(requestParameters.userId, usersCreateTargetMessagingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a token with a secret key for creating a session. If the provided user ID has not be registered, a new user will be created. Use the returned user ID and secret and submit a request to the [PUT /account/sessions/custom](https://appwrite.io/docs/references/cloud/client-web/account#updateCustomSession) endpoint to complete the login process.
         * @summary Create token
         * @param {UsersApiCreateTokenSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTokenSession(requestParameters: UsersApiCreateTokenSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const usersCreateTokenSessionRequest: UsersCreateTokenSessionRequest = {
                length: requestParameters.length,
                expire: requestParameters.expire
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTokenSession(requestParameters.userId, usersCreateTokenSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an authenticator app.
         * @summary Delete Authenticator
         * @param {UsersApiDeleteAuthenticatorRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthenticator(requestParameters: UsersApiDeleteAuthenticatorRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAuthenticator(requestParameters.userId, requestParameters.type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an identity by its unique ID.
         * @summary Delete identity
         * @param {UsersApiDeleteIdentityByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentityById(requestParameters: UsersApiDeleteIdentityByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentityById(requestParameters.identityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a user sessions by its unique ID.
         * @summary Delete user session
         * @param {UsersApiDeleteSessionByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSessionById(requestParameters: UsersApiDeleteSessionByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSessionById(requestParameters.userId, requestParameters.sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a messaging target.
         * @summary Delete user target
         * @param {UsersApiDeleteTargetMessagingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTargetMessaging(requestParameters: UsersApiDeleteTargetMessagingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTargetMessaging(requestParameters.userId, requestParameters.targetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a user by its unique ID, thereby releasing it\'s ID. Since ID is released and can be reused, all user-related resources like documents or storage files should be deleted before user deletion. If you want to keep ID reserved, use the [updateStatus](https://appwrite.io/docs/server/users#usersUpdateStatus) endpoint instead.
         * @summary Delete user
         * @param {UsersApiDeleteUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserById(requestParameters: UsersApiDeleteUserByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserById(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete all user\'s sessions by using the user\'s unique ID.
         * @summary Delete user sessions
         * @param {UsersApiDeleteUserSessionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserSessions(requestParameters: UsersApiDeleteUserSessionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserSessions(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a user by its unique ID.
         * @summary Get user
         * @param {UsersApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(requestParameters: UsersApiGetByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get recovery codes that can be used as backup for MFA flow by User ID. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
         * @summary Get MFA Recovery Codes
         * @param {UsersApiGetMfaRecoveryCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMfaRecoveryCodes(requestParameters: UsersApiGetMfaRecoveryCodesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaRecoveryCodes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMfaRecoveryCodes(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the user preferences by its unique ID.
         * @summary Get user preferences
         * @param {UsersApiGetUserPrefsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPrefs(requestParameters: UsersApiGetUserPrefsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPrefs(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a user\'s push notification target by ID.
         * @summary Get User Target
         * @param {UsersApiGetUserTargetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTargetById(requestParameters: UsersApiGetUserTargetByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Target>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTargetById(requestParameters.userId, requestParameters.targetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all the project\'s users. You can use the query params to filter your results.
         * @summary List users
         * @param {UsersApiListAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAll(requestParameters: UsersApiListAllRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAll(requestParameters.queries, requestParameters.search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the factors available on the account to be used as a MFA challange.
         * @summary List Factors
         * @param {UsersApiListFactorsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFactors(requestParameters: UsersApiListFactorsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaFactors>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFactors(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get identities for all users.
         * @summary List Identities
         * @param {UsersApiListIdentitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentities(requestParameters: UsersApiListIdentitiesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentities(requestParameters.queries, requestParameters.search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the user membership list by its unique ID.
         * @summary List user memberships
         * @param {UsersApiListMembershipsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMemberships(requestParameters: UsersApiListMembershipsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MembershipList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMemberships(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the user sessions list by its unique ID.
         * @summary List user sessions
         * @param {UsersApiListSessionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSessions(requestParameters: UsersApiListSessionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSessions(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the messaging targets that are associated with a user.
         * @summary List User Targets
         * @param {UsersApiListTargetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTargets(requestParameters: UsersApiListTargetsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TargetList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTargets(requestParameters.userId, requestParameters.queries, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the user activity logs list by its unique ID.
         * @summary List user logs
         * @param {UsersApiListUserLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserLogs(requestParameters: UsersApiListUserLogsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserLogs(requestParameters.userId, requestParameters.queries, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Regenerate recovery codes that can be used as backup for MFA flow by User ID. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
         * @summary Regenerate MFA Recovery Codes
         * @param {UsersApiRegenerateMfaRecoveryCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regenerateMfaRecoveryCodes(requestParameters: UsersApiRegenerateMfaRecoveryCodesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaRecoveryCodes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regenerateMfaRecoveryCodes(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user email by its unique ID.
         * @summary Update email
         * @param {UsersApiUpdateEmailByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmailById(requestParameters: UsersApiUpdateEmailByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdateEmailByIdRequest: UsersUpdateEmailByIdRequest = {
                email: requestParameters.email
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmailById(requestParameters.userId, usersUpdateEmailByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user email verification status by its unique ID.
         * @summary Update email verification
         * @param {UsersApiUpdateEmailVerificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmailVerification(requestParameters: UsersApiUpdateEmailVerificationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdateEmailVerificationRequest: UsersUpdateEmailVerificationRequest = {
                emailVerification: requestParameters.emailVerification
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmailVerification(requestParameters.userId, usersUpdateEmailVerificationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user labels by its unique ID.   Labels can be used to grant access to resources. While teams are a way for user\'s to share access to a resource, labels can be defined by the developer to grant access without an invitation. See the [Permissions docs](https://appwrite.io/docs/permissions) for more info.
         * @summary Update user labels
         * @param {UsersApiUpdateLabelsByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLabelsById(requestParameters: UsersApiUpdateLabelsByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdateLabelsByIdRequest: UsersUpdateLabelsByIdRequest = {
                labels: requestParameters.labels
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLabelsById(requestParameters.userId, usersUpdateLabelsByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable or disable MFA on a user account.
         * @summary Update MFA
         * @param {UsersApiUpdateMfaStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMfaStatus(requestParameters: UsersApiUpdateMfaStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdateMfaStatusRequest: UsersUpdateMfaStatusRequest = {
                mfa: requestParameters.mfa
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMfaStatus(requestParameters.userId, usersUpdateMfaStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user password by its unique ID.
         * @summary Update password
         * @param {UsersApiUpdatePasswordByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePasswordById(requestParameters: UsersApiUpdatePasswordByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdatePasswordByIdRequest: UsersUpdatePasswordByIdRequest = {
                password: requestParameters.password
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePasswordById(requestParameters.userId, usersUpdatePasswordByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user phone by its unique ID.
         * @summary Update phone
         * @param {UsersApiUpdatePhoneByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePhoneById(requestParameters: UsersApiUpdatePhoneByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdatePhoneByIdRequest: UsersUpdatePhoneByIdRequest = {
                number: requestParameters.number
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePhoneById(requestParameters.userId, usersUpdatePhoneByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user phone verification status by its unique ID.
         * @summary Update phone verification
         * @param {UsersApiUpdatePhoneVerificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePhoneVerification(requestParameters: UsersApiUpdatePhoneVerificationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdatePhoneVerificationRequest: UsersUpdatePhoneVerificationRequest = {
                phoneVerification: requestParameters.phoneVerification
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePhoneVerification(requestParameters.userId, usersUpdatePhoneVerificationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user preferences by its unique ID. The object you pass is stored as is, and replaces any previous value. The maximum allowed prefs size is 64kB and throws error if exceeded.
         * @summary Update user preferences
         * @param {UsersApiUpdatePreferencesByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePreferencesById(requestParameters: UsersApiUpdatePreferencesByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const usersUpdatePreferencesByIdRequest: UsersUpdatePreferencesByIdRequest = {
                prefs: requestParameters.prefs
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePreferencesById(requestParameters.userId, usersUpdatePreferencesByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user status by its unique ID. Use this endpoint as an alternative to deleting a user if you want to keep user\'s ID reserved.
         * @summary Update user status
         * @param {UsersApiUpdateStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatus(requestParameters: UsersApiUpdateStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdateStatusRequest: UsersUpdateStatusRequest = {
                status: requestParameters.status
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStatus(requestParameters.userId, usersUpdateStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a messaging target.
         * @summary Update User target
         * @param {UsersApiUpdateTargetMessagingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTargetMessaging(requestParameters: UsersApiUpdateTargetMessagingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Target>> {
            const usersUpdateTargetMessagingRequest: UsersUpdateTargetMessagingRequest = {
                identifier: requestParameters.identifier,
                providerId: requestParameters.providerId,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTargetMessaging(requestParameters.userId, requestParameters.targetId, usersUpdateTargetMessagingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the user name by its unique ID.
         * @summary Update name
         * @param {UsersApiUpdateUserByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserByName(requestParameters: UsersApiUpdateUserByNameRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const usersUpdateUserByNameRequest: UsersUpdateUserByNameRequest = {
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserByName(requestParameters.userId, usersUpdateUserByNameRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Create a new user. Password provided must be hashed with the [Argon2](https://en.wikipedia.org/wiki/Argon2) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Argon2 password
         * @param {UsersApiCreateArgon2UserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArgon2User(requestParameters: UsersApiCreateArgon2UserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createArgon2User(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user. Password provided must be hashed with the [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with bcrypt password
         * @param {UsersApiCreateBcryptUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBcryptUser(requestParameters: UsersApiCreateBcryptUserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createBcryptUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user. Password provided must be hashed with the [MD5](https://en.wikipedia.org/wiki/MD5) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with MD5 password
         * @param {UsersApiCreateMd5UserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMd5User(requestParameters: UsersApiCreateMd5UserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createMd5User(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate recovery codes used as backup for MFA flow for User ID. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method by client SDK.
         * @summary Create MFA Recovery Codes
         * @param {UsersApiCreateMfaRecoveryCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMfaRecoveryCodes(requestParameters: UsersApiCreateMfaRecoveryCodesRequest, options?: AxiosRequestConfig): AxiosPromise<MfaRecoveryCodes> {
            return localVarFp.createMfaRecoveryCodes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user.
         * @summary Create user
         * @param {UsersApiCreateNewUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewUser(requestParameters: UsersApiCreateNewUserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createNewUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user. Password provided must be hashed with the [PHPass](https://www.openwall.com/phpass/) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with PHPass password
         * @param {UsersApiCreatePhpassUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhpassUser(requestParameters: UsersApiCreatePhpassUserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createPhpassUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user. Password provided must be hashed with the [Scrypt Modified](https://gist.github.com/Meldiron/eecf84a0225eccb5a378d45bb27462cc) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Scrypt modified password
         * @param {UsersApiCreateScryptModifiedUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScryptModifiedUser(requestParameters: UsersApiCreateScryptModifiedUserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createScryptModifiedUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user. Password provided must be hashed with the [Scrypt](https://github.com/Tarsnap/scrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with Scrypt password
         * @param {UsersApiCreateScryptUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScryptUser(requestParameters: UsersApiCreateScryptUserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createScryptUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a session for a user. Returns an immediately usable session object.  If you want to generate a token for a custom authentication flow, use the [POST /users/{userId}/tokens](https://appwrite.io/docs/server/users#createToken) endpoint.
         * @summary Create session
         * @param {UsersApiCreateSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(requestParameters: UsersApiCreateSessionRequest, options?: AxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.createSession(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user. Password provided must be hashed with the [SHA](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
         * @summary Create user with SHA password
         * @param {UsersApiCreateShaUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShaUser(requestParameters: UsersApiCreateShaUserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createShaUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a messaging target.
         * @summary Create User Target
         * @param {UsersApiCreateTargetMessagingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTargetMessaging(requestParameters: UsersApiCreateTargetMessagingRequest, options?: AxiosRequestConfig): AxiosPromise<Target> {
            return localVarFp.createTargetMessaging(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a token with a secret key for creating a session. If the provided user ID has not be registered, a new user will be created. Use the returned user ID and secret and submit a request to the [PUT /account/sessions/custom](https://appwrite.io/docs/references/cloud/client-web/account#updateCustomSession) endpoint to complete the login process.
         * @summary Create token
         * @param {UsersApiCreateTokenSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTokenSession(requestParameters: UsersApiCreateTokenSessionRequest, options?: AxiosRequestConfig): AxiosPromise<Token> {
            return localVarFp.createTokenSession(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an authenticator app.
         * @summary Delete Authenticator
         * @param {UsersApiDeleteAuthenticatorRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthenticator(requestParameters: UsersApiDeleteAuthenticatorRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.deleteAuthenticator(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an identity by its unique ID.
         * @summary Delete identity
         * @param {UsersApiDeleteIdentityByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityById(requestParameters: UsersApiDeleteIdentityByIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteIdentityById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user sessions by its unique ID.
         * @summary Delete user session
         * @param {UsersApiDeleteSessionByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionById(requestParameters: UsersApiDeleteSessionByIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSessionById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a messaging target.
         * @summary Delete user target
         * @param {UsersApiDeleteTargetMessagingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTargetMessaging(requestParameters: UsersApiDeleteTargetMessagingRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTargetMessaging(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user by its unique ID, thereby releasing it\'s ID. Since ID is released and can be reused, all user-related resources like documents or storage files should be deleted before user deletion. If you want to keep ID reserved, use the [updateStatus](https://appwrite.io/docs/server/users#usersUpdateStatus) endpoint instead.
         * @summary Delete user
         * @param {UsersApiDeleteUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserById(requestParameters: UsersApiDeleteUserByIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all user\'s sessions by using the user\'s unique ID.
         * @summary Delete user sessions
         * @param {UsersApiDeleteUserSessionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserSessions(requestParameters: UsersApiDeleteUserSessionsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserSessions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user by its unique ID.
         * @summary Get user
         * @param {UsersApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(requestParameters: UsersApiGetByIdRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recovery codes that can be used as backup for MFA flow by User ID. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
         * @summary Get MFA Recovery Codes
         * @param {UsersApiGetMfaRecoveryCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMfaRecoveryCodes(requestParameters: UsersApiGetMfaRecoveryCodesRequest, options?: AxiosRequestConfig): AxiosPromise<MfaRecoveryCodes> {
            return localVarFp.getMfaRecoveryCodes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user preferences by its unique ID.
         * @summary Get user preferences
         * @param {UsersApiGetUserPrefsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPrefs(requestParameters: UsersApiGetUserPrefsRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getUserPrefs(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user\'s push notification target by ID.
         * @summary Get User Target
         * @param {UsersApiGetUserTargetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTargetById(requestParameters: UsersApiGetUserTargetByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Target> {
            return localVarFp.getUserTargetById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all the project\'s users. You can use the query params to filter your results.
         * @summary List users
         * @param {UsersApiListAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAll(requestParameters: UsersApiListAllRequest, options?: AxiosRequestConfig): AxiosPromise<UserList> {
            return localVarFp.listAll(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List the factors available on the account to be used as a MFA challange.
         * @summary List Factors
         * @param {UsersApiListFactorsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFactors(requestParameters: UsersApiListFactorsRequest, options?: AxiosRequestConfig): AxiosPromise<MfaFactors> {
            return localVarFp.listFactors(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get identities for all users.
         * @summary List Identities
         * @param {UsersApiListIdentitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdentities(requestParameters: UsersApiListIdentitiesRequest, options?: AxiosRequestConfig): AxiosPromise<IdentityList> {
            return localVarFp.listIdentities(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user membership list by its unique ID.
         * @summary List user memberships
         * @param {UsersApiListMembershipsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMemberships(requestParameters: UsersApiListMembershipsRequest, options?: AxiosRequestConfig): AxiosPromise<MembershipList> {
            return localVarFp.listMemberships(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user sessions list by its unique ID.
         * @summary List user sessions
         * @param {UsersApiListSessionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSessions(requestParameters: UsersApiListSessionsRequest, options?: AxiosRequestConfig): AxiosPromise<SessionList> {
            return localVarFp.listSessions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List the messaging targets that are associated with a user.
         * @summary List User Targets
         * @param {UsersApiListTargetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTargets(requestParameters: UsersApiListTargetsRequest, options?: AxiosRequestConfig): AxiosPromise<TargetList> {
            return localVarFp.listTargets(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user activity logs list by its unique ID.
         * @summary List user logs
         * @param {UsersApiListUserLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserLogs(requestParameters: UsersApiListUserLogsRequest, options?: AxiosRequestConfig): AxiosPromise<LogList> {
            return localVarFp.listUserLogs(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Regenerate recovery codes that can be used as backup for MFA flow by User ID. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
         * @summary Regenerate MFA Recovery Codes
         * @param {UsersApiRegenerateMfaRecoveryCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateMfaRecoveryCodes(requestParameters: UsersApiRegenerateMfaRecoveryCodesRequest, options?: AxiosRequestConfig): AxiosPromise<MfaRecoveryCodes> {
            return localVarFp.regenerateMfaRecoveryCodes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user email by its unique ID.
         * @summary Update email
         * @param {UsersApiUpdateEmailByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailById(requestParameters: UsersApiUpdateEmailByIdRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateEmailById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user email verification status by its unique ID.
         * @summary Update email verification
         * @param {UsersApiUpdateEmailVerificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailVerification(requestParameters: UsersApiUpdateEmailVerificationRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateEmailVerification(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user labels by its unique ID.   Labels can be used to grant access to resources. While teams are a way for user\'s to share access to a resource, labels can be defined by the developer to grant access without an invitation. See the [Permissions docs](https://appwrite.io/docs/permissions) for more info.
         * @summary Update user labels
         * @param {UsersApiUpdateLabelsByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLabelsById(requestParameters: UsersApiUpdateLabelsByIdRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateLabelsById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable or disable MFA on a user account.
         * @summary Update MFA
         * @param {UsersApiUpdateMfaStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMfaStatus(requestParameters: UsersApiUpdateMfaStatusRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateMfaStatus(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user password by its unique ID.
         * @summary Update password
         * @param {UsersApiUpdatePasswordByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordById(requestParameters: UsersApiUpdatePasswordByIdRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updatePasswordById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user phone by its unique ID.
         * @summary Update phone
         * @param {UsersApiUpdatePhoneByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneById(requestParameters: UsersApiUpdatePhoneByIdRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updatePhoneById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user phone verification status by its unique ID.
         * @summary Update phone verification
         * @param {UsersApiUpdatePhoneVerificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneVerification(requestParameters: UsersApiUpdatePhoneVerificationRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updatePhoneVerification(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user preferences by its unique ID. The object you pass is stored as is, and replaces any previous value. The maximum allowed prefs size is 64kB and throws error if exceeded.
         * @summary Update user preferences
         * @param {UsersApiUpdatePreferencesByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreferencesById(requestParameters: UsersApiUpdatePreferencesByIdRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.updatePreferencesById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user status by its unique ID. Use this endpoint as an alternative to deleting a user if you want to keep user\'s ID reserved.
         * @summary Update user status
         * @param {UsersApiUpdateStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatus(requestParameters: UsersApiUpdateStatusRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateStatus(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a messaging target.
         * @summary Update User target
         * @param {UsersApiUpdateTargetMessagingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTargetMessaging(requestParameters: UsersApiUpdateTargetMessagingRequest, options?: AxiosRequestConfig): AxiosPromise<Target> {
            return localVarFp.updateTargetMessaging(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user name by its unique ID.
         * @summary Update name
         * @param {UsersApiUpdateUserByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserByName(requestParameters: UsersApiUpdateUserByNameRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUserByName(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createArgon2User operation in UsersApi.
 * @export
 * @interface UsersApiCreateArgon2UserRequest
 */
export type UsersApiCreateArgon2UserRequest = {
    
} & UsersCreateArgon2UserRequest

/**
 * Request parameters for createBcryptUser operation in UsersApi.
 * @export
 * @interface UsersApiCreateBcryptUserRequest
 */
export type UsersApiCreateBcryptUserRequest = {
    
} & UsersCreateBcryptUserRequest

/**
 * Request parameters for createMd5User operation in UsersApi.
 * @export
 * @interface UsersApiCreateMd5UserRequest
 */
export type UsersApiCreateMd5UserRequest = {
    
} & UsersCreateMd5UserRequest

/**
 * Request parameters for createMfaRecoveryCodes operation in UsersApi.
 * @export
 * @interface UsersApiCreateMfaRecoveryCodesRequest
 */
export type UsersApiCreateMfaRecoveryCodesRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiCreateMfaRecoveryCodes
    */
    readonly userId: string
    
}

/**
 * Request parameters for createNewUser operation in UsersApi.
 * @export
 * @interface UsersApiCreateNewUserRequest
 */
export type UsersApiCreateNewUserRequest = {
    
} & UsersCreateNewUserRequest

/**
 * Request parameters for createPhpassUser operation in UsersApi.
 * @export
 * @interface UsersApiCreatePhpassUserRequest
 */
export type UsersApiCreatePhpassUserRequest = {
    
} & UsersCreatePhpassUserRequest

/**
 * Request parameters for createScryptModifiedUser operation in UsersApi.
 * @export
 * @interface UsersApiCreateScryptModifiedUserRequest
 */
export type UsersApiCreateScryptModifiedUserRequest = {
    
} & UsersCreateScryptModifiedUserRequest

/**
 * Request parameters for createScryptUser operation in UsersApi.
 * @export
 * @interface UsersApiCreateScryptUserRequest
 */
export type UsersApiCreateScryptUserRequest = {
    
} & UsersCreateScryptUserRequest

/**
 * Request parameters for createSession operation in UsersApi.
 * @export
 * @interface UsersApiCreateSessionRequest
 */
export type UsersApiCreateSessionRequest = {
    
    /**
    * User ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can\'t start with a special char. Max length is 36 chars.
    * @type {string}
    * @memberof UsersApiCreateSession
    */
    readonly userId: string
    
}

/**
 * Request parameters for createShaUser operation in UsersApi.
 * @export
 * @interface UsersApiCreateShaUserRequest
 */
export type UsersApiCreateShaUserRequest = {
    
} & UsersCreateShaUserRequest

/**
 * Request parameters for createTargetMessaging operation in UsersApi.
 * @export
 * @interface UsersApiCreateTargetMessagingRequest
 */
export type UsersApiCreateTargetMessagingRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiCreateTargetMessaging
    */
    readonly userId: string
    
} & UsersCreateTargetMessagingRequest

/**
 * Request parameters for createTokenSession operation in UsersApi.
 * @export
 * @interface UsersApiCreateTokenSessionRequest
 */
export type UsersApiCreateTokenSessionRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiCreateTokenSession
    */
    readonly userId: string
    
} & UsersCreateTokenSessionRequest

/**
 * Request parameters for deleteAuthenticator operation in UsersApi.
 * @export
 * @interface UsersApiDeleteAuthenticatorRequest
 */
export type UsersApiDeleteAuthenticatorRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiDeleteAuthenticator
    */
    readonly userId: string
    
    /**
    * Type of authenticator.
    * @type {'totp'}
    * @memberof UsersApiDeleteAuthenticator
    */
    readonly type: 'totp'
    
}

/**
 * Request parameters for deleteIdentityById operation in UsersApi.
 * @export
 * @interface UsersApiDeleteIdentityByIdRequest
 */
export type UsersApiDeleteIdentityByIdRequest = {
    
    /**
    * Identity ID.
    * @type {string}
    * @memberof UsersApiDeleteIdentityById
    */
    readonly identityId: string
    
}

/**
 * Request parameters for deleteSessionById operation in UsersApi.
 * @export
 * @interface UsersApiDeleteSessionByIdRequest
 */
export type UsersApiDeleteSessionByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiDeleteSessionById
    */
    readonly userId: string
    
    /**
    * Session ID.
    * @type {string}
    * @memberof UsersApiDeleteSessionById
    */
    readonly sessionId: string
    
}

/**
 * Request parameters for deleteTargetMessaging operation in UsersApi.
 * @export
 * @interface UsersApiDeleteTargetMessagingRequest
 */
export type UsersApiDeleteTargetMessagingRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiDeleteTargetMessaging
    */
    readonly userId: string
    
    /**
    * Target ID.
    * @type {string}
    * @memberof UsersApiDeleteTargetMessaging
    */
    readonly targetId: string
    
}

/**
 * Request parameters for deleteUserById operation in UsersApi.
 * @export
 * @interface UsersApiDeleteUserByIdRequest
 */
export type UsersApiDeleteUserByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiDeleteUserById
    */
    readonly userId: string
    
}

/**
 * Request parameters for deleteUserSessions operation in UsersApi.
 * @export
 * @interface UsersApiDeleteUserSessionsRequest
 */
export type UsersApiDeleteUserSessionsRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiDeleteUserSessions
    */
    readonly userId: string
    
}

/**
 * Request parameters for getById operation in UsersApi.
 * @export
 * @interface UsersApiGetByIdRequest
 */
export type UsersApiGetByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiGetById
    */
    readonly userId: string
    
}

/**
 * Request parameters for getMfaRecoveryCodes operation in UsersApi.
 * @export
 * @interface UsersApiGetMfaRecoveryCodesRequest
 */
export type UsersApiGetMfaRecoveryCodesRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiGetMfaRecoveryCodes
    */
    readonly userId: string
    
}

/**
 * Request parameters for getUserPrefs operation in UsersApi.
 * @export
 * @interface UsersApiGetUserPrefsRequest
 */
export type UsersApiGetUserPrefsRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiGetUserPrefs
    */
    readonly userId: string
    
}

/**
 * Request parameters for getUserTargetById operation in UsersApi.
 * @export
 * @interface UsersApiGetUserTargetByIdRequest
 */
export type UsersApiGetUserTargetByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiGetUserTargetById
    */
    readonly userId: string
    
    /**
    * Target ID.
    * @type {string}
    * @memberof UsersApiGetUserTargetById
    */
    readonly targetId: string
    
}

/**
 * Request parameters for listAll operation in UsersApi.
 * @export
 * @interface UsersApiListAllRequest
 */
export type UsersApiListAllRequest = {
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, email, phone, status, passwordUpdate, registration, emailVerification, phoneVerification, labels
    * @type {Array<string>}
    * @memberof UsersApiListAll
    */
    readonly queries?: Array<string>
    
    /**
    * Search term to filter your list results. Max length: 256 chars.
    * @type {string}
    * @memberof UsersApiListAll
    */
    readonly search?: string
    
}

/**
 * Request parameters for listFactors operation in UsersApi.
 * @export
 * @interface UsersApiListFactorsRequest
 */
export type UsersApiListFactorsRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiListFactors
    */
    readonly userId: string
    
}

/**
 * Request parameters for listIdentities operation in UsersApi.
 * @export
 * @interface UsersApiListIdentitiesRequest
 */
export type UsersApiListIdentitiesRequest = {
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: userId, provider, providerUid, providerEmail, providerAccessTokenExpiry
    * @type {Array<string>}
    * @memberof UsersApiListIdentities
    */
    readonly queries?: Array<string>
    
    /**
    * Search term to filter your list results. Max length: 256 chars.
    * @type {string}
    * @memberof UsersApiListIdentities
    */
    readonly search?: string
    
}

/**
 * Request parameters for listMemberships operation in UsersApi.
 * @export
 * @interface UsersApiListMembershipsRequest
 */
export type UsersApiListMembershipsRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiListMemberships
    */
    readonly userId: string
    
}

/**
 * Request parameters for listSessions operation in UsersApi.
 * @export
 * @interface UsersApiListSessionsRequest
 */
export type UsersApiListSessionsRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiListSessions
    */
    readonly userId: string
    
}

/**
 * Request parameters for listTargets operation in UsersApi.
 * @export
 * @interface UsersApiListTargetsRequest
 */
export type UsersApiListTargetsRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiListTargets
    */
    readonly userId: string
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, email, phone, status, passwordUpdate, registration, emailVerification, phoneVerification, labels
    * @type {Array<string>}
    * @memberof UsersApiListTargets
    */
    readonly queries?: Array<string>
    
}

/**
 * Request parameters for listUserLogs operation in UsersApi.
 * @export
 * @interface UsersApiListUserLogsRequest
 */
export type UsersApiListUserLogsRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiListUserLogs
    */
    readonly userId: string
    
    /**
    * Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset
    * @type {Array<string>}
    * @memberof UsersApiListUserLogs
    */
    readonly queries?: Array<string>
    
}

/**
 * Request parameters for regenerateMfaRecoveryCodes operation in UsersApi.
 * @export
 * @interface UsersApiRegenerateMfaRecoveryCodesRequest
 */
export type UsersApiRegenerateMfaRecoveryCodesRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiRegenerateMfaRecoveryCodes
    */
    readonly userId: string
    
}

/**
 * Request parameters for updateEmailById operation in UsersApi.
 * @export
 * @interface UsersApiUpdateEmailByIdRequest
 */
export type UsersApiUpdateEmailByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdateEmailById
    */
    readonly userId: string
    
} & UsersUpdateEmailByIdRequest

/**
 * Request parameters for updateEmailVerification operation in UsersApi.
 * @export
 * @interface UsersApiUpdateEmailVerificationRequest
 */
export type UsersApiUpdateEmailVerificationRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdateEmailVerification
    */
    readonly userId: string
    
} & UsersUpdateEmailVerificationRequest

/**
 * Request parameters for updateLabelsById operation in UsersApi.
 * @export
 * @interface UsersApiUpdateLabelsByIdRequest
 */
export type UsersApiUpdateLabelsByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdateLabelsById
    */
    readonly userId: string
    
} & UsersUpdateLabelsByIdRequest

/**
 * Request parameters for updateMfaStatus operation in UsersApi.
 * @export
 * @interface UsersApiUpdateMfaStatusRequest
 */
export type UsersApiUpdateMfaStatusRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdateMfaStatus
    */
    readonly userId: string
    
} & UsersUpdateMfaStatusRequest

/**
 * Request parameters for updatePasswordById operation in UsersApi.
 * @export
 * @interface UsersApiUpdatePasswordByIdRequest
 */
export type UsersApiUpdatePasswordByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdatePasswordById
    */
    readonly userId: string
    
} & UsersUpdatePasswordByIdRequest

/**
 * Request parameters for updatePhoneById operation in UsersApi.
 * @export
 * @interface UsersApiUpdatePhoneByIdRequest
 */
export type UsersApiUpdatePhoneByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdatePhoneById
    */
    readonly userId: string
    
} & UsersUpdatePhoneByIdRequest

/**
 * Request parameters for updatePhoneVerification operation in UsersApi.
 * @export
 * @interface UsersApiUpdatePhoneVerificationRequest
 */
export type UsersApiUpdatePhoneVerificationRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdatePhoneVerification
    */
    readonly userId: string
    
} & UsersUpdatePhoneVerificationRequest

/**
 * Request parameters for updatePreferencesById operation in UsersApi.
 * @export
 * @interface UsersApiUpdatePreferencesByIdRequest
 */
export type UsersApiUpdatePreferencesByIdRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdatePreferencesById
    */
    readonly userId: string
    
} & UsersUpdatePreferencesByIdRequest

/**
 * Request parameters for updateStatus operation in UsersApi.
 * @export
 * @interface UsersApiUpdateStatusRequest
 */
export type UsersApiUpdateStatusRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdateStatus
    */
    readonly userId: string
    
} & UsersUpdateStatusRequest

/**
 * Request parameters for updateTargetMessaging operation in UsersApi.
 * @export
 * @interface UsersApiUpdateTargetMessagingRequest
 */
export type UsersApiUpdateTargetMessagingRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdateTargetMessaging
    */
    readonly userId: string
    
    /**
    * Target ID.
    * @type {string}
    * @memberof UsersApiUpdateTargetMessaging
    */
    readonly targetId: string
    
} & UsersUpdateTargetMessagingRequest

/**
 * Request parameters for updateUserByName operation in UsersApi.
 * @export
 * @interface UsersApiUpdateUserByNameRequest
 */
export type UsersApiUpdateUserByNameRequest = {
    
    /**
    * User ID.
    * @type {string}
    * @memberof UsersApiUpdateUserByName
    */
    readonly userId: string
    
} & UsersUpdateUserByNameRequest

/**
 * UsersApiGenerated - object-oriented interface
 * @export
 * @class UsersApiGenerated
 * @extends {BaseAPI}
 */
export class UsersApiGenerated extends BaseAPI {
    /**
     * Create a new user. Password provided must be hashed with the [Argon2](https://en.wikipedia.org/wiki/Argon2) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
     * @summary Create user with Argon2 password
     * @param {UsersApiCreateArgon2UserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createArgon2User(requestParameters: UsersApiCreateArgon2UserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createArgon2User(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user. Password provided must be hashed with the [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
     * @summary Create user with bcrypt password
     * @param {UsersApiCreateBcryptUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createBcryptUser(requestParameters: UsersApiCreateBcryptUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createBcryptUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user. Password provided must be hashed with the [MD5](https://en.wikipedia.org/wiki/MD5) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
     * @summary Create user with MD5 password
     * @param {UsersApiCreateMd5UserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createMd5User(requestParameters: UsersApiCreateMd5UserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createMd5User(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate recovery codes used as backup for MFA flow for User ID. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method by client SDK.
     * @summary Create MFA Recovery Codes
     * @param {UsersApiCreateMfaRecoveryCodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createMfaRecoveryCodes(requestParameters: UsersApiCreateMfaRecoveryCodesRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createMfaRecoveryCodes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user.
     * @summary Create user
     * @param {UsersApiCreateNewUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createNewUser(requestParameters: UsersApiCreateNewUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createNewUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user. Password provided must be hashed with the [PHPass](https://www.openwall.com/phpass/) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
     * @summary Create user with PHPass password
     * @param {UsersApiCreatePhpassUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createPhpassUser(requestParameters: UsersApiCreatePhpassUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createPhpassUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user. Password provided must be hashed with the [Scrypt Modified](https://gist.github.com/Meldiron/eecf84a0225eccb5a378d45bb27462cc) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
     * @summary Create user with Scrypt modified password
     * @param {UsersApiCreateScryptModifiedUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createScryptModifiedUser(requestParameters: UsersApiCreateScryptModifiedUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createScryptModifiedUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user. Password provided must be hashed with the [Scrypt](https://github.com/Tarsnap/scrypt) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
     * @summary Create user with Scrypt password
     * @param {UsersApiCreateScryptUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createScryptUser(requestParameters: UsersApiCreateScryptUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createScryptUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a session for a user. Returns an immediately usable session object.  If you want to generate a token for a custom authentication flow, use the [POST /users/{userId}/tokens](https://appwrite.io/docs/server/users#createToken) endpoint.
     * @summary Create session
     * @param {UsersApiCreateSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createSession(requestParameters: UsersApiCreateSessionRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createSession(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user. Password provided must be hashed with the [SHA](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm) algorithm. Use the [POST /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to create users with a plain text password.
     * @summary Create user with SHA password
     * @param {UsersApiCreateShaUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createShaUser(requestParameters: UsersApiCreateShaUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createShaUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a messaging target.
     * @summary Create User Target
     * @param {UsersApiCreateTargetMessagingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createTargetMessaging(requestParameters: UsersApiCreateTargetMessagingRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createTargetMessaging(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a token with a secret key for creating a session. If the provided user ID has not be registered, a new user will be created. Use the returned user ID and secret and submit a request to the [PUT /account/sessions/custom](https://appwrite.io/docs/references/cloud/client-web/account#updateCustomSession) endpoint to complete the login process.
     * @summary Create token
     * @param {UsersApiCreateTokenSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public createTokenSession(requestParameters: UsersApiCreateTokenSessionRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createTokenSession(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an authenticator app.
     * @summary Delete Authenticator
     * @param {UsersApiDeleteAuthenticatorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public deleteAuthenticator(requestParameters: UsersApiDeleteAuthenticatorRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteAuthenticator(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an identity by its unique ID.
     * @summary Delete identity
     * @param {UsersApiDeleteIdentityByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public deleteIdentityById(requestParameters: UsersApiDeleteIdentityByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteIdentityById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user sessions by its unique ID.
     * @summary Delete user session
     * @param {UsersApiDeleteSessionByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public deleteSessionById(requestParameters: UsersApiDeleteSessionByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteSessionById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a messaging target.
     * @summary Delete user target
     * @param {UsersApiDeleteTargetMessagingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public deleteTargetMessaging(requestParameters: UsersApiDeleteTargetMessagingRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteTargetMessaging(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user by its unique ID, thereby releasing it\'s ID. Since ID is released and can be reused, all user-related resources like documents or storage files should be deleted before user deletion. If you want to keep ID reserved, use the [updateStatus](https://appwrite.io/docs/server/users#usersUpdateStatus) endpoint instead.
     * @summary Delete user
     * @param {UsersApiDeleteUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public deleteUserById(requestParameters: UsersApiDeleteUserByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all user\'s sessions by using the user\'s unique ID.
     * @summary Delete user sessions
     * @param {UsersApiDeleteUserSessionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public deleteUserSessions(requestParameters: UsersApiDeleteUserSessionsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserSessions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user by its unique ID.
     * @summary Get user
     * @param {UsersApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getById(requestParameters: UsersApiGetByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recovery codes that can be used as backup for MFA flow by User ID. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
     * @summary Get MFA Recovery Codes
     * @param {UsersApiGetMfaRecoveryCodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getMfaRecoveryCodes(requestParameters: UsersApiGetMfaRecoveryCodesRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getMfaRecoveryCodes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user preferences by its unique ID.
     * @summary Get user preferences
     * @param {UsersApiGetUserPrefsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getUserPrefs(requestParameters: UsersApiGetUserPrefsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserPrefs(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user\'s push notification target by ID.
     * @summary Get User Target
     * @param {UsersApiGetUserTargetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getUserTargetById(requestParameters: UsersApiGetUserTargetByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserTargetById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all the project\'s users. You can use the query params to filter your results.
     * @summary List users
     * @param {UsersApiListAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listAll(requestParameters: UsersApiListAllRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listAll(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the factors available on the account to be used as a MFA challange.
     * @summary List Factors
     * @param {UsersApiListFactorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listFactors(requestParameters: UsersApiListFactorsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listFactors(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get identities for all users.
     * @summary List Identities
     * @param {UsersApiListIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listIdentities(requestParameters: UsersApiListIdentitiesRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listIdentities(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user membership list by its unique ID.
     * @summary List user memberships
     * @param {UsersApiListMembershipsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listMemberships(requestParameters: UsersApiListMembershipsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listMemberships(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user sessions list by its unique ID.
     * @summary List user sessions
     * @param {UsersApiListSessionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listSessions(requestParameters: UsersApiListSessionsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listSessions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the messaging targets that are associated with a user.
     * @summary List User Targets
     * @param {UsersApiListTargetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listTargets(requestParameters: UsersApiListTargetsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listTargets(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user activity logs list by its unique ID.
     * @summary List user logs
     * @param {UsersApiListUserLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listUserLogs(requestParameters: UsersApiListUserLogsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUserLogs(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Regenerate recovery codes that can be used as backup for MFA flow by User ID. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method.
     * @summary Regenerate MFA Recovery Codes
     * @param {UsersApiRegenerateMfaRecoveryCodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public regenerateMfaRecoveryCodes(requestParameters: UsersApiRegenerateMfaRecoveryCodesRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).regenerateMfaRecoveryCodes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user email by its unique ID.
     * @summary Update email
     * @param {UsersApiUpdateEmailByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updateEmailById(requestParameters: UsersApiUpdateEmailByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateEmailById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user email verification status by its unique ID.
     * @summary Update email verification
     * @param {UsersApiUpdateEmailVerificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updateEmailVerification(requestParameters: UsersApiUpdateEmailVerificationRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateEmailVerification(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user labels by its unique ID.   Labels can be used to grant access to resources. While teams are a way for user\'s to share access to a resource, labels can be defined by the developer to grant access without an invitation. See the [Permissions docs](https://appwrite.io/docs/permissions) for more info.
     * @summary Update user labels
     * @param {UsersApiUpdateLabelsByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updateLabelsById(requestParameters: UsersApiUpdateLabelsByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateLabelsById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable or disable MFA on a user account.
     * @summary Update MFA
     * @param {UsersApiUpdateMfaStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updateMfaStatus(requestParameters: UsersApiUpdateMfaStatusRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateMfaStatus(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user password by its unique ID.
     * @summary Update password
     * @param {UsersApiUpdatePasswordByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updatePasswordById(requestParameters: UsersApiUpdatePasswordByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updatePasswordById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user phone by its unique ID.
     * @summary Update phone
     * @param {UsersApiUpdatePhoneByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updatePhoneById(requestParameters: UsersApiUpdatePhoneByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updatePhoneById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user phone verification status by its unique ID.
     * @summary Update phone verification
     * @param {UsersApiUpdatePhoneVerificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updatePhoneVerification(requestParameters: UsersApiUpdatePhoneVerificationRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updatePhoneVerification(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user preferences by its unique ID. The object you pass is stored as is, and replaces any previous value. The maximum allowed prefs size is 64kB and throws error if exceeded.
     * @summary Update user preferences
     * @param {UsersApiUpdatePreferencesByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updatePreferencesById(requestParameters: UsersApiUpdatePreferencesByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updatePreferencesById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user status by its unique ID. Use this endpoint as an alternative to deleting a user if you want to keep user\'s ID reserved.
     * @summary Update user status
     * @param {UsersApiUpdateStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updateStatus(requestParameters: UsersApiUpdateStatusRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateStatus(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a messaging target.
     * @summary Update User target
     * @param {UsersApiUpdateTargetMessagingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updateTargetMessaging(requestParameters: UsersApiUpdateTargetMessagingRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateTargetMessaging(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user name by its unique ID.
     * @summary Update name
     * @param {UsersApiUpdateUserByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public updateUserByName(requestParameters: UsersApiUpdateUserByNameRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserByName(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
